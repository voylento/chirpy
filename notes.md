
## PSQL
-Connect to database:
```
psql "postgres://dwroth:@localhost:5432/chirpy"
```

## GOOSE
Goose is a database migration tool written in Go. Good fit for projects that want to stay close to raw SQL.  A migration is a set of changes to a database. For example, adding or modifying a table. An 'up' migration changes the state of a database from its current schema to a new schema. A 'down' migration changes the state of a database to a previous migration. For simple application can store the migration files in the sql/schemas subdirectory. 

Let's walk through an example. Say we want to create an 'up' migration that creates a simple user table in our  database and a 'down' migration that removes the table. First, we navigate in the terminal to the sql/schema subdirectory and then tell goose to create a 'create user table' migration. From our sql/schemas subdirectory:
```
goose create create_user_table sql
```
Goose creates a file that looks like this:
```
-- +goose Up
-- +goose StatementBegin
SELECT 'up SQL query';
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
SELECT 'down SQL query';
-- +goose StatementEnd
```
We then add our SQL code to create (or drop) the user table:
```
-- +goose Up
-- +goose StatementBegin
CREATE TABLE users (
  id          UUID PRIMARY KEY,
  created_at  TIMESTAMP NOT NULL,
  updated_at  TIMESTAMP NOT NULL,
  name        TEXT UNIQUE NOT NULL
);
-- +goose StatementEnd

-- +goose Down
-- +goose StatementBegin
DROP TABLE users;
-- +goose StatementEnd
```

Assuming that a database is already created and you have a connection string, run the migrations. Again, run
this command from the sql/schema subdirectory. If we assume a connection string of `postgres://voylento:@localhost:5432/mydb`  
then the goose command to run an up migration is:
```
goose postgres "postgres://voylento:@localhost:5432/mydb" up
```

You can then use psql to verify the table has been created:
```
>psql -U voylento -d postgres
psql (15.13 (Homebrew))
Type "help" for help.

postgres=# \c mydb
You are now connected to database "mydb" as user "voylento"
mydb=# \d users
...
```

## SQLC
-Installation
```
go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest
```
Run `sqlc version` to ensure sqlc is installed correctly.  

[SQLC Postgres docs](https://docs.sqlc.dev/en/latest/tutorials/getting-started-postgresql.html)  

-Configuration (sqlc.yaml):
```
version: "2"
sql:
  - schema: "sql/schema"
    queries: "sql/queries"
    engine: "postgresql"
    gen:
      go:
        out: "internal/database"
```
-Example workflow:
1. Write a query in directories sql/queries. I typically use a file named queries.sql. Here is an example query to create a user in a hypothetical user table:
```
--name: CreateUser :one
INSERT INTO users (id, created_at, updated_at, email)
VALUES (
    gen_random_uuid(),
    NOW(),
    NOW(),
    $1
)
RETURNING *;
```
Sqlc relies on the format of the metadata line preceding the SQL query. CreateUser is the name of the function sqlc will generate, and `:one` tells sqlc that the query will return one result: the user that was created.  

2. From project root:
```
sqlc generate
```
3. Notice that generated code (in internal/database subdir) relies on Google's [`uuid`](https://pkg.go.dev/github.com/google/uuidpackage). Add that to your module and then to the code sqlc generated: 
```
go get github.com/google/uuid
```
add "github.com/google/uuid" and "time" to internal/database/queries.sql.go:
```
package database

import (
	"context"
	"database/sql"
	"time"
	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, created_at, updated_at, email)
VALUES (
  gen_random_uuid(),
  NOW(),
  NOW(),
  $1
)
RETURNING id, created_at, updated_at, email
`

func (q *Queries) CreateUser(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
	)
	return i, err
}

```
4. Need to add a Postgres driver so the program can communicate with the database
```
go get github.com/lib/pq
```

5. Import pq into project
```
import _ "github.com/lib/pq"
```
NOTE: use `_` if only importing package for side effects (as in this case). This is prevent compiler error complaining  
that import isn't used.

6. Create a `.env` file at root of project that contains the DB connection string. In this example, my OS account name is voylento:
```
DB_URL="postgres://voylento:@localhost:5432/mydatabase?sslmode=disable3
```
7. Add godotenv to project so that you can use os.Getenv to get the database connection string from the environment config:
```
go get github.com/joho/godotenv
```
```
dbUrl := os.Getenv("DB_URL")
db, err := sql.Open("postgres", dbUrl)
```

8. Use the database package generated by SQLC to create a new *database.Queries variable and store it in the app config for easy access:
```
dbQueries := database.New(db)
```


